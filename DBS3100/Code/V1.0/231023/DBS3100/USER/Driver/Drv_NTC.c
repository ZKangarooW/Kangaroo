#include "Drv_NTC.h"

/*********局部变量**********/
const uint16_t R100K_TAB[401] = //R25=100K B25=3950K -25-150
{
	58,//-48
	63,//-47
	67,//-46
	72,//-45
	77,//-44
	83,//-43
	89,//-42
	95,//-41
	102,//-40
	109,//-39
	116,//-38
	124,//-37
	132,//-36
	141,//-35
	150,//-34
	160,//-33
	170,//-32
	181,//-31
	192,//-30
	204,//-29
	217,//-28
	230,//-27
	244,//-26
	259,//-25
	274,//-24
	290,//-23
	306,//-22
	324,//-21
	342,//-20
	361,//-19
	381,//-18
	401,//-17
	423,//-16
	445,//-15
	468,//-14
	492,//-13
	517,//-12
	543,//-11
	570,//-10
	597,//-9
	626,//-8
	655,//-7
	685,//-6
	717,//-5
	749,//-4
	782,//-3
	815,//-2
	850,//-1
	886,//0
	922,//1
	959,//2
	997,//3
	103,//4
	107,//5 
	1115,//6
	1156,//7 
	1198,//8 
	1240,//9 
	1288,//10
	1320,//11
	1340,//12
	1360,//13 
	1395,//14
	1430,//15 
	1480,//16
	1540,//17 
	1590,//18 
	1620,//19
	1668,//20 
	1712,//21 
	1774,//22
	1820,//23
	1870,//24
	1904,//25
	1976,//26
	2000,//27
	2030,//28
	2080,//29
	2120,//30
	2170,//31
	2220,//32
	2265,//33
	2325,//34
	2365,//35
	2400,//36
	2450,//37
	2490,//38
	2530,//39
	2570,//40
	2590,//41
	2647,//42
	2680,//43
	2721,//44
	2753,//45
	2784,//46
	2820,//47
	2850,//48
	2888,//49
	2911,//50
	2950,//51
	2977,//52
	3007,//53
	3034,//54
	3050,//55
	3080,//56
	3105,//57
	3130,//58
	3154,//59
	3181,//60
	3218,//61
	3230,//62
	3267,//63
	3295,//64
	3313,//65
	3338,//66
	3348,//67
	3366,//68
	3388,//69
	3409,//70
	3425,//71
	3450,//72
	3461,//73
	3486,//74
	3495,//75
	3505,//76
	3528,//77
	3545,//78
	3555,//79
	3565,//80
	3574,//81
	3581,//82
	3597,//83
	3607,//84
	3620,//85
	3631,//86
	3641,//87
	3651,//88
	3664,//89
	3677,//90
	3682,//91
	3694,//92
	3707,//93
	3718,//94
	3727,//95
	3732,//96
	3741,//97
	3751,//98
	3756,//99
	3764,//100
	3795, 
	3803, 
	3812,
	3820, 
	3827, 
	3835, 
	3842, 
	3849, 
	3856, 
	3862, 
	3869, 
	3875, 
	3881, 
	3887, 
	3893, 
	3898, 
	3903, 
	3909, 
	3914, 
	3919, 
	3923, 
	3928, 
	3932, 
	3937, 
	3941, 
	3945, 
	3949, 
	3953, 
	3956, 
	3960, 
	3964, 
	3967, 
	3970, 
	3973, 
	3977, 
	3980, 
	3983, 
	3985, 
	3988, 
	3991, 
	3993, 
	3996, 
	3998, 
	4001, 
	4003, 
	4005, 
	4008, 
	4010, 
	4012, 
	4014, 
	4016, 
	4018, 
	4020, 
	4022, 
	4023, 
	4025, 
	4027, 
	4028, 
	4030, 
	4031, 
	4033, 
	4034, 
	4036, 
	4037, 
	4039, 
	4040, 
	4041, 
	4042, 
	4044, 
	4045, 
	4046, 
	4047, 
	4048, 
	4049, 
	4050, 
	4051, 
	4052, 
	4053, 
	4054, 
	4055, 
	4056, 
	4057, 
	4058, 
	4058, 
	4059, 
	4060, 
	4061, 
	4061, 
	4062, 
	4063, 
	4064, 
	4064, 
	4065, 
	4066, 
	4066, 
	4067, 
	4067, 
	4068, 
	4069, 
	4069, 
	4070, 
	4070, 
	4071, 
	4071, 
	4072, 
	4072, 
	4073, 
	4073, 
	4074, 
	4074, 
	4074, 
	4075, 
	4075, 
	4076, 
	4076, 
	4076, 
	4077, 
	4077, 
	4077, 
	4078, 
	4078, 
	4079, 
	4079, 
	4079, 
	4079, 
	4080, 
	4080, 
	4080, 
	4081, 
	4081, 
	4081, 
	4081, 
	4082, 
	4082, 
	4082, 
	4082, 
	4083, 
	4083, 
	4083, 
	4083, 
	4084, 
	4084, 
	4084, 
	4084, 
	4084, 
	4085, 
	4085, 
	4085, 
	4085, 
	4085, 
	4086, 
	4086, 
	4086, 
	4086, 
	4086, 
	4086, 
	4087, 
	4087, 
	4087, 
	4087, 
	4087, 
	4087, 
	4087, 
	4088, 
	4088, 
	4088, 
	4088, 
	4088, 
	4088, 
	4088, 
	4088, 
	4089, 
	4089, 
	4089, 
	4089, 
	4089, 
	4089, 
	4089, 
	4089, 
	4089, 
	4090, 
	4090, 
	4090, 
	4090, 
	4090, 
	4090, 
	4090, 
	4090, 
	4090, 
	4090, 
	4090, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4091, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4092, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093, 
	4093,
	4093,
	4093, 
	4093, 
	4093, 
	4093, 
	4093,
	4093, 
	4093, 
	4093,
	4093, 
	4093
};

/**********全局变量**********/
#define AD_LEN 2//DMA获取长度
uint16_t ADC_Val[AD_LEN];//adc的值 0:内部探头。 1：热盖的探头
uint16_t ADC_Val1,ADC_Val2;

/*
*****************************************************************
 * 函数原型：int Filter_ADC(void)
 * 功    能：中位值滤波法,连续采样N次（N取奇数），把N次采样值按大小排列，取中间值为本次有效值。
 * 输    出：滤波后的值
*****************************************************************
*/
#define N 9
int ADCvalue_Buf[N];//用于储存采集到的adc值
int Filter_ADC(void)
{  
	uint16_t count,i,j,temp;
	for(count=0;count<N;count++)
	{
		ADCvalue_Buf[count] = ADC_Val[0];//将adc的值储存
	}
	for(j=0;j<N-1;j++)
	{
		for(i=0;i<N-j;i++)
		{
			if(ADCvalue_Buf[i] >  ADCvalue_Buf[i+1])
			{
				temp = ADCvalue_Buf[i];
				ADCvalue_Buf [i]= ADCvalue_Buf[i+1];
				ADCvalue_Buf[i+1] = temp;
			}
		}
	}

	return ADCvalue_Buf[(N-1)/2];
}

///*
//*****************************************************************
// * 函数原型：int Filter_ADC(void)
// * 功    能：滑动平均值滤波
// * 输    出：滤波后的值
//*****************************************************************
//*/
//#define N1 50//采集100次
//int ADCvalue_Buf2[N1];//用于储存采集到的adc值
//int i = 0;
//int Filter_ADC2(void)
//{
//    uint8_t count;
//    long sum = 0;
//    
//    ADCvalue_Buf2[i++] = Filter_ADC();//将adc的值储存
//	
//    if (i == N1)//加入读了100组就从新开始
//    {
//        i = 0;
//    }
//    for (count = 0; count < N; count++)
//    {
//        sum += ADCvalue_Buf2[count];//100组相加
//    }
//    if(ADCvalue_Buf2[N-1] == 0)//如果没有读到100组就用第一次读到的数
//        return ADCvalue_Buf2[0];
//    else//读到100组后
//        return (int)(sum / N);//输出平均值
//}

/*
*****************************************************************
 * 函数原型：int Filter_ADC1(void)
 * 功    能：中位值滤波法,连续采样N次（N取奇数），把N次采样值按大小排列，取中间值为本次有效值。
 * 输    出：滤波后的值
*****************************************************************
*/
int ADCvalue_Buf1[N];//用于储存采集到的adc值
int Filter_ADC1(void)
{  
	uint16_t count,i,j,temp;
	for(count=0;count<N;count++)
	{
		ADCvalue_Buf1[count] = ADC_Val[1];//将adc的值储存
	}
	for(j=0;j<N-1;j++)
	{
		for(i=0;i<N-j;i++)
		{
			if(ADCvalue_Buf1[i] >  ADCvalue_Buf1[i+1])
			{
				temp = ADCvalue_Buf1[i];
				ADCvalue_Buf1 [i]= ADCvalue_Buf1[i+1];
				ADCvalue_Buf1[i+1] = temp;
			}
		}
	}
	return ADCvalue_Buf1[(N-1)/2];
}

/*
*****************************************************************
 * 函数原型：uint16_t Get_Ntc_Temp(uint16_t value_adc)
 * 功    能：计算出Ntc的温度
 * 输    入: value_adc:adc读到的值
 * 参    数：uint16_t value_adc
*****************************************************************
*/
#define SHORT_CIRCUIT_THRESHOLD 15
#define OPEN_CIRCUIT_THRESHOLD 4096
uint16_t index_l, index_r ;
uint16_t Get_Ntc_Temp(uint16_t value_adc)
{
    uint16_t R100k_Tab_Size = 401;
    int temp = 0;
    if(value_adc <= SHORT_CIRCUIT_THRESHOLD)
    {
        return 1;
    }
    else if(value_adc >= OPEN_CIRCUIT_THRESHOLD)
    {
        return 2;
    }
    else if(value_adc < R100K_TAB[0])
    {
        return 3;
    }

    else if(value_adc > R100K_TAB[R100k_Tab_Size - 1])
    {
        return 4;
    }

    index_l = 0;
    index_r = R100k_Tab_Size - 1;
    for(; index_r - index_l > 1;)
    {
        if((value_adc <= R100K_TAB[index_r]) && (value_adc > R100K_TAB[(index_l + index_r) % 2 == 0 ? (index_l + index_r) / 2 : (index_l + index_r) / 2 ]))
        {
            index_l = (index_l + index_r) % 2 == 0 ? (index_l + index_r) / 2 : (index_l + index_r) / 2 ;
        }
        else
        {
            index_r = (index_l + index_r) / 2;
        }
    }
    if(R100K_TAB[index_l] == value_adc)
    {
        temp = (((int)index_l) - 48) * 10; //rate *10
    }
    else if(R100K_TAB[index_r] == value_adc)
    {
        temp = (((int)index_r) - 48) * 10; //rate *10
    }
    else
    {
        if(R100K_TAB[index_r] - R100K_TAB[index_l] == 0)
        {
            temp = (((int)index_l) - 48) * 10; //rate *10
        }
        else
        {
            temp = (((int)index_l) - 48) * 10 + ((value_adc - R100K_TAB[index_l] ) * 100 + 5) / 10 / (R100K_TAB[index_r] - R100K_TAB[index_l]);
        }
    }

    /******************温度补偿*********************/
    return temp;
}

/*
*****************************************************************
 * 函数原型：uint16_t Get_ADCVal(uint16_t temp)
 * 功    能：计算当前温度的adc值
 * 输    入：temp：当前温度
 * 输    出：ADC值
 * 参    数：uint16_t temp
*****************************************************************
*/

uint16_t Get_ADCVal(uint16_t temp)
{
	uint16_t adc,adc1;
	float val2;
	uint16_t val3,val1;
	
	val3 = (temp/10)+48;
	val2 = (float)(temp%10)/10;
	
	val1 = ((temp+10)/10)+47;
	
	adc = R100K_TAB[val3];
	adc1 = R100K_TAB[val1];
	return adc+((adc1-adc)*val2);
}

/*
*****************************************************************
 * 函数原型：void ADCDMA_Init(void)
 * 功    能：ADC和DMA的初始化
*****************************************************************
*/
void ADCDMA_Init(void)
{
    HAL_TIM_Base_Start_IT(&htim15);//开启TIM3的定时，用于刷新
	HAL_ADC_Start_DMA(&hadc,(uint32_t *)ADC_Val, AD_LEN);//用DMA获取adc值
	HAL_ADCEx_Calibration_Start(&hadc);
	for(uint8_t i=0;i<10;i++)
	{
		Temp.HEAT_GAI  = Get_Ntc_Temp(ADC_Val[1]);//计算温度
		Temp.Rel = Get_Ntc_Temp(ADC_Val[0]);//计算温度
		HAL_Delay(10);
	}
}

/* 
*****************************************************************
 * 函数原型：void Read_Temp(float dT)
 * 功    能：读取温度
*****************************************************************
*/
//uint16_t RelTemp_Old,AlarmTemp_Old;
void Read_Temp(float dT)
{
    static float T;
    T += dT;
	ADC_Val1 = Filter_ADC();//滤波获取adc的滑动平均值
	ADC_Val2 = Filter_ADC1();//滤波获取adc的滑动平均值

    if(T >= 0.2f)//1S
    {
//		RelTemp_Old = Temp.Rel;
//		AlarmTemp_Old = Temp.HEAT_GAI; 
		Temp.HEAT_GAI = Get_Ntc_Temp(ADC_Val2);//计算温度
		Temp.Rel = Get_Ntc_Temp(ADC_Val1);//计算温度
		T = 0;
    }
}
