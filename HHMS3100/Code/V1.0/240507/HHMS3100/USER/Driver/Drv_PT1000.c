#include "Drv_PT1000.h"

/*
-50-390摄氏度
*/
#define PT1000_Tab_Size 441
const float Temp_map[PT1000_Tab_Size]=
{
803.06,
807.03,
811.00,
814.97,
818.94,
822.90,
826.87,
830.83,
834.79,
838.75,
842.71,
846.66,
850.62,
854.57,
858.53,
862.48,
866.43,
870.38,
874.32,
878.27,
882.22,
886.16,
890.10,
894.04,
897.98,
901.92,
905.86,
909.80,
913.73,
917.67,
921.60,
925.53,
929.46,
933.39,
937.32,
941.24,
945.17,
949.09,
953.02,
956.94,
960.86,
964.78,
968.70,
972.61,
976.53,
980.44,
984.36,
988.27,
992.18,
996.09,
1000.00,
1003.91,
1007.81,
1011.72,
1015.62,
1019.53,
1023.43,
1027.33,
1031.23,
1035.13,
1039.03,
1042.92,
1046.82,
1050.71,
1054.60,
1058.49,
1062.38,
1066.27,
1070.16,
1074.05,
1077.94,
1081.82,
1085.70,
1089.59,
1093.47,
1097.35,
1101.23,
1105.10,
1108.98,
1112.86,
1116.73,
1120.60,
1124.47,
1128.35,
1132.21,
1136.08,
1139.95,
1143.82,
1147.68,
1151.55,
1155.41,
1159.27,
1163.13,
1166.99,
1170.85,
1174.70,
1178.56,
1182.41,
1186.27,
1190.12,
1193.97,
1197.82,
1201.67,
1205.52,
1209.36,
1213.21,
1217.05,
1220.90,
1224.74,
1228.58,
1232.42,
1236.26,
1240.09,
1243.93,
1247.77,
1251.60,
1255.43,
1259.26,
1263.09,
1266.92,
1270.75,
1274.58,
1278.40,
1282.23,
1286.05,
1289.87,
1293.70,
1297.52,
1301.33,
1305.15,
1308.97,
1312.78,
1316.60,
1320.41,
1324.22,
1328.03,
1331.84,
1335.65,
1339.46,
1343.26,
1347.07,
1350.87,
1354.68,
1358.48,
1362.28,
1366.08,
1369.87,
1373.67,
1377.47,
1381.26,
1385.06,
1388.85,
1392.64,
1396.43,
1400.22,
1404.00,
1407.79,
1411.58,
1415.36,
1419.14,
1422.93,
1426.71,
1430.49,
1434.26,
1438.04,
1441.82,
1445.59,
1449.37,
1453.14,
1456.91,
1460.68,
1464.45,
1468.22,
1471.98,
1475.75,
1479.51,
1483.28,
1487.04,
1490.80,
1494.56,
1498.32,
1502.08,
1505.83,
1509.59,
1513.34,
1517.10,
1520.85,
1524.60,
1528.35,
1532.10,
1535.84,
1539.59,
1543.33,
1547.08,
1550.82,
1554.56,
1558.30,
1562.04,
1565.78,
1569.52,
1573.25,
1576.99,
1580.72,
1584.45,
1588.18,
1591.91,
1595.64,
1599.37,
1603.09,
1606.82,
1610.54,
1614.27,
1617.99,
1621.71,
1625.43,
1629.15,
1632.86,
1636.58,
1640.30,
1644.01,
1647.72,
1651.43,
1655.14,
1658.85,
1662.56,
1666.27,
1669.97,
1673.68,
1677.38,
1681.08,
1684.78,
1688.48,
1692.18,
1695.88,
1699.58,
1703.27,
1706.96,
1710.66,
1714.35,
1718.04,
1721.73,
1725.42,
1729.10,
1732.79,
1736.48,
1740.16,
1743.84,
1747.52,
1751.20,
1754.88,
1758.56,
1762.24,
1765.91,
1769.59,
1773.26,
1776.93,
1780.60,
1784.27,
1787.94,
1791.61,
1795.28,
1798.94,
1802.60,
1806.27,
1809.93,
1813.59,
1817.25,
1820.91,
1824.56,
1828.22,
1831.88,
1835.53,
1839.18,
1842.83,
1846.48,
1850.13,
1853.78,
1857.43,
1861.07,
1864.72,
1868.36,
1872.00,
1875.64,
1879.28,
1882.92,
1886.56,
1890.19,
1893.83,
1897.46,
1901.10,
1904.73,
1908.36,
1911.99,
1915.62,
1919.24,
1922.87,
1926.49,
1930.12,
1933.74,
1937.36,
1940.98,
1944.60,
1948.22,
1951.83,
1955.45,
1959.06,
1962.68,
1966.29,
1969.90,
1973.51,
1977.12,
1980.73,
1984.33,
1987.94,
1991.54,
1995.14,
1998.75,
2002.35,
2005.95,
2009.54,
2013.14,
2016.74,
2020.33,
2023.93,
2027.52,
2031.11,
2034.70,
2038.29,
2041.88,
2045.46,
2049.05,
2052.63,
2056.22,
2059.80,
2063.38,
2066.96,
2070.54,
2074.11,
2077.69,
2081.27,
2084.84,
2088.41,
2091.98,
2095.55,
2099.12,
2102.69,
2106.26,
2109.82,
2113.39,
2116.95,
2120.52,
2124.08,
2127.64,
2131.20,
2134.75,
2138.31,
2141.87,
2145.42,
2148.97,
2152.52,
2156.08,
2159.62,
2163.17,
2166.72,
2170.27,
2173.81,
2177.36,
2180.90,
2184.44,
2187.98,
2191.52,
2195.06,
2198.60,
2202.13,
2205.67,
2209.20,
2212.73,
2216.26,
2219.79,
2223.32,
2226.85,
2230.38,
2233.90,
2237.43,
2240.95,
2244.47,
2247.99,
2251.51,
2255.03,
2258.55,
2262.06,
2265.58,
2269.09,
2272.60,
2276.12,
2279.63,
2283.14,
2286.64,
2290.15,
2293.66,
2297.16,
2300.66,
2304.17,
2307.67,
2311.17,
2314.67,
2318.16,
2321.66,
2325.16,
2328.65,
2332.14,
2335.64,
2339.13,
2342.62,
2346.10,
2349.59,
2353.08,
2356.56,
2360.05,
2363.53,
2367.01,
2370.49,
2373.97,
2377.45,
2380.93,
2384.40,
2387.88,
2391.35,
2394.82,
2398.29,
2401.76,
2405.23,
2408.70,
2412.17,
2415.63,
2419.10,
2422.56,
2426.02,
2429.48,
2432.94,
2436.40
};

/**********全局变量**********/
#define OP_Value	6.8//放大系数
#define Vref_3V3	3.30//3.3V电压
#define K1			0.2327367//电阻基准系数
#define Vref		2.494//参考电压
#define IIR(x,y) (x)=((x) * 9 + (y)) / 10//滤波
uint16_t ADC_Val[AD_LEN];//adc的值

#define N 100//采集100次
int ADCvalue_Buf[AD_LEN][N];//用于储存采集到的adc值
uint8_t j[AD_LEN];
/**
 * @brief 滑动平均值滤波
 * 
 * @param i adc的通道
 * @return int 滤波后的值
 */
int Filter_ADC(uint8_t i)
{
    uint8_t count;
    long sum = 0;

	ADCvalue_Buf[i][j[i]++] = ADC_Val[i];
	
    if (j[i] == N)//加入读了100组就从新开始
    {
        j[i] = 0;
    }
	for (count = 0; count < N; count++)
	{
		sum += ADCvalue_Buf[i][count];//100组相加
	}
    if(ADCvalue_Buf[i][N-1] == 0)//如果没有读到100组就用第一次读到的数
        return ADCvalue_Buf[i][0];
    else//读到100组后
        return (int)(sum / N);//输出平均值
}

// float temp_correct[AD_LEN];//温度系数
float ADC_Val_Avg[AD_LEN];//温度的值
float AD_T[AD_LEN];//ADC计算后的电压值
float PT_VALUE_TEMP[AD_LEN];//阻值
/**
 * @brief 计算阻值
 * 
 */
void AFE_Sample_Handler(void)
{
    // temp_correct = 1.00167f;
	// temp_correct1 = 1.0f;

	for (uint8_t  i = 0; i < AD_LEN; i++)
	{
		ADC_Val_Avg[i] = Filter_ADC(i);
        if(ADC_Val_Avg[i] <= 3700)//最低限制，目前数值还很大，3210.81，将以下的值滤掉
            ADC_Val_Avg[i] = 3700;
		AD_T[i] = 3.3f/((3.3*ADC_Val_Avg[i]/4096)/30000)-30000;//计算电压值
		PT_VALUE_TEMP[i] = AD_T[i];//计算电阻值
	}
}

#define SHORT_CIRCUIT_THRESHOLD 723//短路阈值
#define OPEN_CIRCUIT_THRESHOLD 2810//开路阈值

/**
 * @brief 查表
 * 
 * @param tmp 计算出的电阻值
 * @return int 温度R
 */
int AFE_GetTemperature(float value_R)
{
	int temp = 0;
    uint16_t index_l, index_r;
	if (value_R <= SHORT_CIRCUIT_THRESHOLD)
    {
        return 1;//短路返回的错误码
    }
    else if (value_R >= OPEN_CIRCUIT_THRESHOLD)
    {
        return 2;//开路返回的错误码
    }
    else if (value_R < Temp_map[0])
    {
        return 3;//超出下标的错误码
    }

    else if (value_R > Temp_map[PT1000_Tab_Size - 1])
    {
        return 4;//超出上限的错误码
    }
	index_l = 0;
    index_r = PT1000_Tab_Size - 1;

	for (; index_r - index_l > 1;)
    {
        if ((value_R <= Temp_map[index_r]) && (value_R > Temp_map[(index_l + index_r) % 2 == 0 ? (index_l + index_r) / 2 : (index_l + index_r) / 2]))
        {
            index_l = (index_l + index_r) % 2 == 0 ? (index_l + index_r) / 2 : (index_l + index_r) / 2;
        }
        else
        {
            index_r = (index_l + index_r) / 2;
        }
    }

	if (Temp_map[index_l] == value_R)
    {
        temp = (((int)index_l) - 48) * 10; // rate *10
    }
    else if (Temp_map[index_r] == value_R)
    {
        temp = (((int)index_r) - 48) * 10; // rate *10
    }
    else
    {
        if (Temp_map[index_r] - Temp_map[index_l] == 0)
        {
            temp = (((int)index_l) - 48) * 10; // rate *10
        }
        else
        {
            temp = (((int)index_l) - 48) * 10 + ((value_R - Temp_map[index_l]) * 100 + 5) / 10 / (Temp_map[index_r] - Temp_map[index_l]);
        }
    }
	return temp;
}


/**
 * @brief 查表读ADC值
 * 
 * @param temp 温度
 * @return float adc的值
 */
float Get_ADCVal(int16_t temp)
{
	float adc_Val;
	if(temp < 0)//小于0摄氏度
	{
		adc_Val  =  Temp_map[220 + temp];
	}
	else if(temp >= 0 && temp < 1000)
	{
		adc_Val = Temp_map[220 + temp];
	}
	else if(temp >= 1000)
	{
		adc_Val = Temp_map[1220 + (temp-1000)/10];
	}
	return adc_Val;
}

/*
*****************************************************************
 * 函数原型：void Read_Temp(float dT)
 * 功    能：读取温度-10ms
*****************************************************************
*/
void Read_Temp(float dT)
{
	static float T;
	
	T += dT;
	AFE_Sample_Handler();//计算阻值

	Work_Num[2].Temp.Mesa = AFE_GetTemperature(PT_VALUE_TEMP[0]);
    Work_Num[0].Temp.Mesa = AFE_GetTemperature(PT_VALUE_TEMP[2]);
	Work_Num[3].Temp.Mesa = AFE_GetTemperature(PT_VALUE_TEMP[4]);
    Work_Num[1].Temp.Mesa = AFE_GetTemperature(PT_VALUE_TEMP[6]);

	if(T >= 1.0f)
	{
		// if(PT_VALUE_TEMP[0] < 913.733)//假如没有插入外部探头
		// 	Temp.Rel = Temp.Mesa;//真实温度显示台面温度
		// else//假如插入外部探头
		// 	Temp.Rel = Temp.Outside;//真实温度显示外部探头测的温度
		T = 0;
	}
}

/**
 * @brief ADC和DMA的初始化
 * 
 */
void ADCDMA_Init(void)
{
    HAL_ADCEx_Calibration_Start(&hadc1);//校准
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)ADC_Val, AD_LEN);//用DMA获取ADC的值
	for(uint8_t i = 0; i < 200; i++)
	{
		AFE_Sample_Handler();//计算阻值
		Read_Temp(0.6f);
	}
}


/**
 * @brief PT1000任务
 * 
 */
void PT1000_Task(void *p)
{
    TickType_t xLastWakeTime;//刚开始唤醒的时间
    xLastWakeTime = xTaskGetTickCount ();

    /**********初始化ADC_DMA***********/
    ADCDMA_Init();
    
    while(1)
    {
        Read_Temp(0.1f);
        vTaskDelayUntil(&xLastWakeTime, 100);
    }
}

