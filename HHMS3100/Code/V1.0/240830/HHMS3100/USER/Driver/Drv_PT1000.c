#include "Drv_PT1000.h"

/*
-22-400摄氏度
*/
const float Temp_map[423]=
{
/*-22*/913.733, 	 
/*-21*/917.666, 	
/*-20*/921.599, 	 
/*-19*/925.531, 	
/*-18*/929.460, 	 
/*-17*/933.390, 	
/*-16*/937.317, 	 
/*-15*/941.244, 	
/*-14*/945.170,
/*-13*/949.094,
/*-12*/953.016,  
/*-11*/956.938,
/*-10*/960.859, 
/*-9*/964.779, 
/*-8*/968.697, 
/*-7*/972.614,
/*-6*/976.529,
/*-5*/980.444,
/*-4*/984.358,
/*-3*/988.270,
/*-2*/992.181,	
/*-1*/996.091,
/*0*/1000.000,
/*1*/1003.908,
/*2*/1007.814,
/*3*/1011.720,
/*4*/1015.624, 
/*5*/1019.527, 
/*6*/1023.429, 
/*7*/1027.330, 
/*8*/1031.229, 
/*9*/1035.128, 
/*10*/1039.025, 
/*11*/1042.921, 
/*12*/1046.816, 
/*13*/1050.710, 
/*14*/1054.603, 
/*15*/1058.495, 
/*16*/1062.385, 
/*17*/1066.27,
/*18*/1070.162, 
/*19*/1074.049, 
/*20*/1077.935, 
/*21*/1081.820, 
/*22*/1085.703, 
/*23*/1089.585, 
/*24*/1093.467, 
/*25*/1097.347, 
/*26*/1101.225, 
/*27*/1105.103, 
/*28*/1108.980, 
/*29*/1112.855, 
/*30*/1116.729, 
/*31*/1120.602, 
/*32*/1124.474, 
/*33*/1128.345, 
/*34*/1132.215, 
/*35*/1136.083, 
/*36*/1139.950, 
/*37*/1143.817, 
/*38*/1147.681, 
/*39*/1151.545, 
/*40*/1155.408, 
/*41*/1159.270, 
/*42*/1163.130, 
/*43*/1166.989, 
/*44*/1170.847, 
/*45*/1174.704, 	
/*46*/1178.560, 	
/*47*/1182.414, 	
/*48*/1186.268, 
/*49*/1190.120, 
/*50*/1193.971, 
/*51*/1197.821, 
/*52*/1201.670, 
/*53*/1205.518, 	
/*54*/1209.364, 
/*55*/1213.210, 
/*56*/1217.054, 
/*57*/1220.897, 
/*58*/1224.739, 
/*59*/1228.579, 
/*60*/1232.419, 
/*61*/1236.257, 
/*62*/1240.095, 	
/*63*/1243.931, 	
/*64*/1247.766, 	
/*65*/1251.600, 	
/*66*/1255.432, 	
/*67*/1259.264, 	
/*68*/1263.094, 	
/*69*/1266.923,
/*70*/1270.751, 
/*71*/1274.578, 
/*72*/1278.404, 
/*73*/1282.228, 
/*74*/1286.052, 
/*75*/1289.874, 
/*76*/1293.695, 
/*77*/1297.515, 
/*78*/1301.334, 
/*79*/1305.152, 	
/*80*/1308.968, 
/*81*/1312.783,	
/*82*/1316.597,	
/*83*/1320.411,	
/*84*/1324.222,	
/*85*/1328.033,	
/*86*/1331.843,	
/*87*/1335.651,	
/*88*/1339.458,	
/*89*/1343.264,	
/*90*/1347.069,	
/*91*/1350.873,	
/*92*/1354.676,	
/*93*/1358.477,	
/*94*/1362.277,	
/*95*/1366.077,	
/*96*/1369.875,	
/*97*/1373.671,	
/*98*/1377.467,	
/*99*/1381.262, 
/*100*/	1385.055, 	1388.847, 	1392.638, 	1396.428, 	1400.217, 	1404.005, 	1407.791, 	1411.576, 	1415.360, 	1419.143,
/*110*/	1422.925, 	1426.706,	1430.485, 	1434.264, 	1438.041, 	1441.817, 	1445.592, 	1449.366, 	1453.138, 	1456.910, 
/*120*/	1460.680, 	1464.449, 	1468.217, 	1471.984, 	1475.750,	1479.514, 	1483.277, 	1487.040, 	1490.801, 	1494.561, 
/*130*/	1498.319, 	1502.077, 	1505.833, 	1509.589, 	1513.343, 	1517.096, 	1520.847, 	1524.598, 	1528.381, 	1532.139, 
/*140*/	1535.843, 	1539.589, 	1543.334, 	1547.078, 	1550.820, 	1554.562, 	1558.302, 	1562.041, 	1565.779, 	1569.516, 
/*150*/	1573.251, 	1576.986, 	1580.719, 	1584.451, 	1588.182, 	1591.912, 	1595.641, 	1599.368, 	1603.094, 	1606.820,
/*160*/	1610.544, 	1614.267, 	1617.989, 	1621.709, 	1625.429,	1629.147, 	1632.864, 	1636.580, 	1640.295, 	1644.009, 
/*170*/	1647.721, 	1651.433, 	1655.143, 	1658.852, 	1662.560,	1666.267, 	1669.972, 	1673.677, 	1677.380, 	1681.082, 
/*180*/	1684.783, 	1688.483, 	1692.181, 	1695.879, 	1699.575, 	1703.271, 	1706.965, 	1710.658, 	1714.349, 	1718.040, 
/*190*/	1721.729, 	1725.418, 	1729.105, 	1732.791, 	1736.475, 	1740.159, 	1743.842, 	1747.523, 	1751.203, 	1754.882, 
/*200*/	1758.560, 	1762.237, 	1765.912, 	1769.587, 	1773.260, 	1776.932,	1780.603, 	1784.273, 	1787.941, 	1791.610, 
/*210*/1795.275, 	1798.940, 	1802.604, 	1806.267, 	1809.929, 	1813.590, 	1817.249, 	1820.907, 	1824.564, 	1828.220, 
/*220*/1831.875, 	1835.529, 	1839.181, 	1842.832, 	1846.483, 	1850.132, 	1853.779, 	1857.426, 	1861.072, 	1864.716, 
/*230*/1868.359, 	1872.001, 	1875.642, 	1879.282, 	1882.921, 	1886.558, 	1890.194, 	1893.830, 	1897.463, 	1901.096, 
/*240*/1904.728, 	1908.359, 	1911.988, 	1915.616, 	1919.243, 	1922.869, 	1926.494, 	1930.117, 	1933.740, 	1937.361, 
/*250*/1940.981, 	1944.600, 	1948.218, 	1951.835, 	1955.450, 	1959.065, 	1962.678, 	1966.290, 	1969.901, 	1973.510, 
/*260*/1977.119, 	1980.726,	1984.333, 	1987.938, 	1991.542, 	1995.145, 	1998.746, 	2002.347,	2005.946, 	2009.544, 
/*270*/2013.141, 	2016.737, 	2020.332, 	2023.925, 	2027.518, 	2031.109, 	2034.699, 	2038.288, 	2041.876, 	2045.463, 
/*280*/2049.048, 	2052.632, 	2056.215, 	2059.798, 	2063.378, 	2066.958, 	2070.537, 	2074.114, 	2077.690, 	2081.265, 
/*290*/2084.839, 	2088.412, 	2091.984, 	2095.554, 	2099.123, 	2102.692, 	2106.259, 	2109.824, 	2113.389, 	2116.953, 
/*300*/ 2120.515,	2124.08,	2127.64,	2131.20,	2134.75,	2138.31,	2141.87,	2145.42,	2148.97,	2152.52,	
/*310*/ 2156.08,	2159.62,	2163.17,	2166.72,	2170.27,	2173.81,	2177.36,	2180.90,	2184.44,	2187.98,
/*320*/ 2191.52,	2195.06,	2198.60,	2202.13,	2205.67,	2209.20,	2212.73,	2216.26,	2219.79,	2223.32,
/*330*/ 2226.85,	2230.38,	2233.90,	2237.43,	2240.95,	2244.47,	2247.99,	2251.51,	2255.03,	2258.55,
/*340*/ 2262.06,	2265.58,	2269.09,	2272.60,	2276.12,	2279.63,	2283.14,	2286.64,	2290.15,	2293.66,
/*350*/ 2297.16,	2300.66,	2304.17,	2307.67,	2311.17,	2314.67,	2318.16,	2321.66,	2325.16,	2328.65,	
/*360*/ 2332.14,	2335.64,	2339.13,	2342.62,	2346.10,	2349.59,	2353.08,	2356.56,	2360.05,	2363.53,	
/*370*/ 2367.01,	2370.49,	2373.97,	2377.45,	2380.93,	2384.40,	2387.88,	2391.35,	2394.82,	2398.29,
/*380*/ 2401.76,	2405.23,	2408.70,	2412.17,	2415.63,	2419.10,	2422.56,	2426.02,	2429.48,	2432.94,
/*390*/ 2436.40,	2439.86,	2443.31,	2446.77,	2450.22,	2453.67,	2457.13,	2460.58,	2464.03,	2467.47,
/*400*/ 2470.92
};

/**********全局变量**********/
uint16_t ADC_Val[AD_LEN];//adc的值 0:台面温度ad值。 1：外部探头ad值
uint32_t ADC1_Val,ADC2_Val;//adc的值
#define OP_Value	6.8//放大系数
#define Vref_3V3	3.30//3.3V电压
#define K1			0.2327367//电阻基准系数
#define Vref		2.497//参考电压

/*
*****************************************************************
 * 函数原型：int Filter_ADC(void)
 * 功    能：滑动平均值滤波
 * 输    出：滤波后的值
*****************************************************************
*/
#define N 100//采集100次
int ADCvalue_Buf[4][N];//用于储存采集到的adc值
int i[4];
int Filter_ADC(uint8_t new_work)
{
    char count;
    long sum = 0;

    ADCvalue_Buf[new_work][i[new_work]++] =ADC_Val[(2*new_work)];
	
    if (i[new_work] == N)//假如读了100组就从新开始
    {
        i[new_work] = 0;
    }
    for (count = 0; count < N; count++)
    {
        sum += ADCvalue_Buf[new_work][count];//100组相加
    }
    if(ADCvalue_Buf[new_work][N-1] == 0)//如果没有读到100组就用第一次读到的数
        return ADCvalue_Buf[new_work][0];
    else//读到100组后
        return (int)(sum / N);//输出平均值
}

/*
*****************************************************************
 * 函数原型：int Filter_ADC1(void)
 * 功    能：滑动平均值滤波
 * 输    出：滤波后的值
*****************************************************************
*/
int ADCvalue_Buf1[4][N];//用于储存采集到的adc值
int j[4];
int Filter_ADC1(uint8_t new_work)
{
    char count;
    long sum = 0;

    ADCvalue_Buf1[new_work][j[new_work]++] =ADC_Val[((2*new_work)+1)];
	
    if (j[new_work] == N)//假如读了100组就从新开始
    {
        j[new_work] = 0;
    }
    for (count = 0; count < N; count++)
    {
        sum += ADCvalue_Buf1[new_work][count];//100组相加
    }
    if(ADCvalue_Buf1[new_work][N-1] == 0)//如果没有读到100组就用第一次读到的数
        return ADCvalue_Buf1[new_work][0];
    else//读到100组后
        return (int)(sum / N);//输出平均值
}

/*
*****************************************************************
 * 函数原型：void AFE_Sample_Handler(void)
 * 功    能：计算阻值
*****************************************************************
*/
float temp_correct[4];//温度系数
float ADC_Val_Avg[4][2];//0为台面温度  1为探头温度
float AD_T1=0.0;//ADC计算后的电压值
float AD_T2=0.0;//ADC计算后的电压值
float PT_VALUE_1_TEMP[4];//外部探头阻值
float PT_VALUE_2_TEMP[4];//台面探头阻值

float PT_VALUE_1_TEMP1[4];//外部探头阻值
float PT_VALUE_2_TEMP1[4];//台面探头阻值
void AFE_Sample_Handler(void)
{
    temp_correct[0] = 1.002004f;
    temp_correct[1] = 1.002004f;
    temp_correct[2] = 1.002004f;
    temp_correct[3] = 1.002004f;
    
	uint8_t j;
    for(uint8_t i = 0;i<4;i++)
    {
        ADC_Val_Avg[i][0] = Filter_ADC(i);
        ADC_Val_Avg[i][1] = Filter_ADC1(i);
        
        AD_T1=((float)ADC_Val_Avg[i][1]*Vref_3V3/4096)/OP_Value/Vref+K1;//计算电压值
        AD_T2=((float)ADC_Val_Avg[i][0]*Vref_3V3/4096)/OP_Value/Vref+K1;//计算电压值
        
        if(i == 0)
            j = 2;
        else if(i == 1)
            j = 0;
        else if(i == 2)
            j = 3;
        else
            j = 1;
        PT_VALUE_1_TEMP1[j]=(3000*AD_T1/(1-AD_T1));//计算电阻值
        PT_VALUE_2_TEMP1[j]=(3000*AD_T2/(1-AD_T2));//计算电阻值
        PT_VALUE_1_TEMP[j]=(3000*AD_T1/(1-AD_T1))*temp_correct[i];//计算电阻值
        PT_VALUE_2_TEMP[j]=(3000*AD_T2/(1-AD_T2))*temp_correct[i];//计算电阻值
    }
}

uint16_t index_l, index_r;
/**
 * @brief 计算出PT1000的温度
 *
 * @param value_adc adc读到的电阻值
 * @return uint16_t 温度或者状态
 */
uint16_t AFE_GetTemperature(float value_adc)
{
    uint16_t R100k_Tab_Size = 423;
    int temp = 0;
    if (value_adc < Temp_map[0])
    {
        return 1;
    }

    else if (value_adc > Temp_map[R100k_Tab_Size - 1])
    {
        return 2;
    }

    index_l = 0;
    index_r = R100k_Tab_Size - 1;
    for (; index_r - index_l > 1;)
    {
        if ((value_adc <= Temp_map[index_r]) && (value_adc > Temp_map[(index_l + index_r) % 2 == 0 ? (index_l + index_r) / 2 : (index_l + index_r) / 2]))
        {
            index_l = (index_l + index_r) % 2 == 0 ? (index_l + index_r) / 2 : (index_l + index_r) / 2;
        }
        else
        {
            index_r = (index_l + index_r) / 2;
        }
    }
    if (Temp_map[index_l] == value_adc)
    {
        temp = (((int)index_l) - 22) * 10; // rate *10
    }
    else if (Temp_map[index_r] == value_adc)
    {
        temp = (((int)index_r) - 22) * 10; // rate *10
    }
    else
    {
        if (Temp_map[index_r] - Temp_map[index_l] == 0)
        {
            temp = (((int)index_l) - 22) * 10; // rate *10
        }
        else
        {
            temp = (((int)index_l) - 22) * 10 + ((value_adc - Temp_map[index_l]) * 100 + 5) / 10 / (Temp_map[index_r] - Temp_map[index_l]);
        }
    }

    return temp;
}

/*
*****************************************************************
 * 函数原型：void Read_Temp(float dT)
 * 功    能：读取温度-10ms
*****************************************************************
*/
void Read_Temp(float dT)
{
	static float T;
    T += dT;
        
    if(T >= 1.0f)
    {
        for(uint8_t i = 0;i<4;i++)
        {
            if(PT_VALUE_1_TEMP[i] < 2200)//假如插入外部探头
                Work_Num[i].Temp.Rel = Work_Num[i].Temp.Outside;//真实温度显示外部探头测的温度
            else//假如没有插入外部探头
                Work_Num[i].Temp.Rel = Work_Num[i].Temp.Mesa;//真实温度显示台面温度
        } 
        T = 0;
    }
}

/**
 * @brief ADC和DMA的初始化
 * 
 */
void ADCDMA_Init(void)
{
    HAL_ADCEx_Calibration_Start(&hadc1);//校准
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)ADC_Val, AD_LEN);//用DMA获取ADC的值
	
    for(uint8_t i = 0; i < 100; i++)
	{
        AFE_Sample_Handler();//计算阻值
        for(uint8_t j = 0;j<4;j++)
        {
            Work_Num[j].Temp.Outside = AFE_GetTemperature(PT_VALUE_1_TEMP[j]);//外部温度
            Work_Num[j].Temp.Mesa = AFE_GetTemperature(PT_VALUE_2_TEMP[j]);//台面温度
            Read_Temp(0.6f);
            Work_Num[j].Temp.Display_Rel = Work_Num[j].Temp.Rel;
        }
	}
}

/*
*****************************************************************
 * 函数原型：float Get_ADCVal(int16_t temp)
 * 功    能：查表读ADC值
*****************************************************************
*/
float Get_ADCVal(int16_t temp)
{
	int16_t adc,adc1;
	float val2;
	int16_t val3,val1;
	
	val3 = (temp/10)+48;
	val2 = (float)(temp%10)/10;
	
	val1 = ((temp+10)/10)+48;
	
	adc = Temp_map[val3];
	adc1 = Temp_map[val1];
	return adc+((adc1-adc)*val2);
}

/**
 * @brief PT1000任务
 * 
 */
void PT1000_Task(void *p)
{ 
    while(1)
    {
        for(uint8_t i = 0;i<4;i++)
        {
            AFE_Sample_Handler();//计算阻值
            Work_Num[i].Temp.Outside = AFE_GetTemperature(PT_VALUE_1_TEMP[i]);//外部温度
            Work_Num[i].Temp.Mesa = AFE_GetTemperature(PT_VALUE_2_TEMP[i]);//台面温度
        }
        Read_Temp(0.01f);
        vTaskDelay(10);
    }
}

